make examples
make[1]: Entering directory '/home/jglass/Documents/pyscript/pyscriptjs'
mkdir -p ./examples
cp -r ../examples/* ./examples
chmod -R 755 examples
find ./examples/toga -type f -name '*.html' -exec sed -i s+https://pyscript.net/latest/+../../build/+g {} \;
find ./examples/webgl -type f -name '*.html' -exec sed -i s+https://pyscript.net/latest/+../../../build/+g {} \;
find ./examples -type f -name '*.html' -exec sed -i s+https://pyscript.net/latest/+../build/+g {} \;
npm run build

> pyscript@0.0.1 build
> npm run tsc && node esbuild.mjs


> pyscript@0.0.1 tsc
> tsc --noEmit

[1mpyscript[0m [2m(prod)[0m built in: 86.342ms
rm -rf ./examples/build
mkdir -p ./examples/build
cp -R ./build/* ./examples/build
To serve examples run: conda run -p /home/jglass/Documents/pyscript/pyscriptjs/env python -m http.server 8080 --directory examples
make[1]: Leaving directory '/home/jglass/Documents/pyscript/pyscriptjs'
make test-ts
make[1]: Entering directory '/home/jglass/Documents/pyscript/pyscriptjs'
npm run test

> pyscript@0.0.1 test
> cross-env NODE_OPTIONS=--experimental-vm-modules jest --coverage

  console.warn
    A unique error message

      75 |             break;
      76 |         case 'log-warning-true':
    > 77 |             console.warn(message);
         |                     ^
      78 |             break;
      79 |     }
      80 |

      at warn (src/exceptions.ts:77:21)
      at _createAlertBanner (src/utils.ts:112:9)
      at Object.<anonymous> (tests/unit/utils.test.ts:57:13)

  console.error
    Something went wrong!

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at error (src/exceptions.ts:74:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:11:9)

  console.warn
    This is a warning

      75 |             break;
      76 |         case 'log-warning-true':
    > 77 |             console.warn(message);
         |                     ^
      78 |             break;
      79 |     }
      80 |

      at warn (src/exceptions.ts:77:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:21:9)

  console.error
    Something went wrong!

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at console.<anonymous> (node_modules/jest-mock/build/index.js:709:23)
      at error (src/exceptions.ts:74:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:33:9)

  console.warn
    This warning

      75 |             break;
      76 |         case 'log-warning-true':
    > 77 |             console.warn(message);
         |                     ^
      78 |             break;
      79 |     }
      80 |

      at console.<anonymous> (node_modules/jest-mock/build/index.js:709:23)
      at warn (src/exceptions.ts:77:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:41:9)

  console.warn
    Warning!

      75 |             break;
      76 |         case 'log-warning-true':
    > 77 |             console.warn(message);
         |                     ^
      78 |             break;
      79 |     }
      80 |

      at console.<anonymous> (node_modules/jest-mock/build/index.js:709:23)
      at warn (src/exceptions.ts:77:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:50:9)

  console.error
    <p>Test message</p>

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at console.<anonymous> (node_modules/jest-mock/build/index.js:709:23)
      at error (src/exceptions.ts:74:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:85:9)

  console.error
    <p>Test message</p>

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at console.<anonymous> (node_modules/jest-mock/build/index.js:709:23)
      at error (src/exceptions.ts:74:21)
      at Object.<anonymous> (tests/unit/exceptions.test.ts:98:9)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading  /covfefe.json

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading  /covfefe.json

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.error
    (PY0000): Computer says no

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at error (src/exceptions.ts:74:21)
      at MyApp._createAlertBanner [as _handleUserErrorMaybe] (src/main.ts:136:13)
      at MyApp._handleUserErrorMaybe [as main] (src/main.ts:115:24)
      at Object.<anonymous> (tests/unit/main.test.ts:30:9)

  console.error
    (PY0000): hello <br>

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at error (src/exceptions.ts:74:21)
      at MyApp._createAlertBanner [as _handleUserErrorMaybe] (src/main.ts:136:13)
      at MyApp._handleUserErrorMaybe [as main] (src/main.ts:115:24)
      at Object.<anonymous> (tests/unit/main.test.ts:42:9)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.error
    (PY0000): hello <br>

      72 |     switch (`log-${level}-${logMessage}`) {
      73 |         case 'log-error-true':
    > 74 |             console.error(message);
         |                     ^
      75 |             break;
      76 |         case 'log-warning-true':
      77 |             console.warn(message);

      at error (src/exceptions.ts:74:21)
      at MyApp._createAlertBanner [as _handleUserErrorMaybe] (src/main.ts:136:13)
      at MyApp._handleUserErrorMaybe [as main] (src/main.ts:115:24)
      at Object.<anonymous> (tests/unit/main.test.ts:54:9)

  console.info
    [py-config] loading  /covfefe.json

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading  /covfefe.json

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [py-config] loading <py-config> content

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [pyscript/pyodide] importing pyscript

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [pyscript/pyodide] pyodide loaded and initialized

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [pyscript/pyodide] pyodide.loadPackage: numpy

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [pyscript/pyodide] Loading numpy

      at Object.out_fn [as info] (src/logger.ts:50:13)

  console.info
    [pyscript/pyodide] Loaded numpy

      at Object.out_fn [as info] (src/logger.ts:50:13)

---------------------------|---------|----------|---------|---------|---------------------------------
File                       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s               
---------------------------|---------|----------|---------|---------|---------------------------------
All files                  |    37.2 |    42.47 |   38.21 |   37.73 |                                 
 pyscriptjs                |     100 |    83.33 |     100 |     100 |                                 
  directoryManifest.mjs    |     100 |    83.33 |     100 |     100 | 40                              
 pyscriptjs/src            |   53.07 |    59.23 |   51.18 |   54.56 |                                 
  exceptions.ts            |   95.34 |      100 |   83.33 |   95.34 | 61-62                           
  fetch.ts                 |   94.11 |    88.88 |     100 |   94.11 | 53                              
  interpreter_client.ts    |   56.25 |      100 |   42.85 |   56.25 | 75-92                           
  logger.ts                |     100 |      100 |     100 |     100 |                                 
  main.ts                  |    16.9 |       20 |   17.39 |   16.54 | 35-37,120-129,147-434,443       
  plugin.ts                |   14.28 |        0 |   16.66 |   15.38 | 150-218,243-267                 
  pyconfig.ts              |   86.31 |    74.41 |    92.3 |   86.31 | 117,121,128,177,211-225         
  pyexec.ts                |    4.34 |        0 |       0 |    4.34 | 14-73                           
  remote_interpreter.ts    |      45 |     9.09 |   45.45 |      45 | 104,134-135,146,166-255,268-273 
  stdio.ts                 |   96.77 |       70 |     100 |   96.55 | 73                              
  utils.ts                 |   73.58 |       65 |   63.63 |   77.55 | 4-11,45,58,92,130-134           
  version.ts               |     100 |      100 |     100 |     100 |                                 
 pyscriptjs/src/components |    2.76 |        0 |       0 |    2.76 |                                 
  elements.ts              |       0 |      100 |       0 |       0 | 7-11                            
  pyrepl.ts                |    2.38 |        0 |       0 |    2.38 | 36-224                          
  pyscript.ts              |     3.5 |        0 |       0 |     3.5 | 26-70,170-250                   
  pywidget.ts              |    2.77 |        0 |       0 |    2.77 | 14-100                          
 pyscriptjs/src/plugins    |   14.76 |    21.53 |      20 |   14.58 |                                 
  calculateFetchPaths.ts   |     100 |      100 |     100 |     100 |                                 
  importmap.ts             |    5.55 |        0 |       0 |    6.25 | 24-50                           
  pyterminal.ts            |    8.69 |        0 |    9.09 |    9.09 | 14-24,38-138                    
  splashscreen.ts          |    9.09 |     7.69 |   11.11 |    9.09 | 31-62,69-107                    
  stdiodirector.ts         |       5 |        0 |      20 |       5 | 34-128                          
---------------------------|---------|----------|---------|---------|---------------------------------
make[1]: Leaving directory '/home/jglass/Documents/pyscript/pyscriptjs'
make test-py
make[1]: Entering directory '/home/jglass/Documents/pyscript/pyscriptjs'
Tests from /home/jglass/Documents/pyscript/pyscriptjs/src
mkdir -p test_results
/home/jglass/Documents/pyscript/pyscriptjs/env/bin/pytest -vv  tests/py-unit/ --log-cli-level=warning --junitxml=test_results/py-unit.xml
============================= test session starts ==============================
platform linux -- Python 3.11.0, pytest-7.1.2, pluggy-1.0.0 -- /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python
cachedir: .pytest_cache
Test order randomisation NOT enabled. Enable with --random-order or --random-order-bucket=<bucket_type>
rootdir: /home/jglass/Documents/pyscript/pyscriptjs
plugins: random-order-1.1.0, base-url-2.0.0, playwright-0.3.2, xdist-3.2.1, instafail-0.5.0
collecting ... collected 19 items

tests/py-unit/test_pyscript.py::TestElement::test_id_is_correct PASSED   [  5%]
tests/py-unit/test_pyscript.py::TestElement::test_element PASSED         [ 10%]
tests/py-unit/test_pyscript.py::test_format_mime_str PASSED              [ 15%]
tests/py-unit/test_pyscript.py::test_format_mime_str_escaping PASSED     [ 21%]
tests/py-unit/test_pyscript.py::test_format_mime_repr_escaping PASSED    [ 26%]
tests/py-unit/test_pyscript.py::test_format_mime_HTML PASSED             [ 31%]
tests/py-unit/test_pyscript.py::test_uses_top_level_await PASSED         [ 36%]
tests/py-unit/test_pyscript.py::test_set_version_info PASSED             [ 42%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_repr PASSED   [ 47%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_show_warning_override PASSED [ 52%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_getattr PASSED [ 57%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_dont_show_warning_twice PASSED [ 63%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_call PASSED   [ 68%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_iter PASSED   [ 73%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_getitem PASSED [ 78%]
tests/py-unit/test_pyscript.py::TestDeprecatedGlobal::test_setitem PASSED [ 84%]
tests/py-unit/test_python_plugins.py::TestPyMarkdown::test_plugin_hooks PASSED [ 89%]
tests/py-unit/test_python_plugins.py::TestPyTutor::test_connected_calls PASSED [ 94%]
tests/py-unit/test_python_plugins.py::TestPyTutor::test_plugin_registered PASSED [100%]

=============================== warnings summary ===============================
src/python/pyscript/__init__.py:26
  /home/jglass/Documents/pyscript/pyscriptjs/src/python/pyscript/__init__.py:26: DeprecationWarning: There is no current event loop
    loop = asyncio.get_event_loop()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
- generated xml file: /home/jglass/Documents/pyscript/pyscriptjs/test_results/py-unit.xml -
======================== 19 passed, 1 warning in 0.04s =========================
make[1]: Leaving directory '/home/jglass/Documents/pyscript/pyscriptjs'
make test-integration-parallel
make[1]: Entering directory '/home/jglass/Documents/pyscript/pyscriptjs'
make examples
make[2]: Entering directory '/home/jglass/Documents/pyscript/pyscriptjs'
mkdir -p ./examples
cp -r ../examples/* ./examples
chmod -R 755 examples
find ./examples/toga -type f -name '*.html' -exec sed -i s+https://pyscript.net/latest/+../../build/+g {} \;
find ./examples/webgl -type f -name '*.html' -exec sed -i s+https://pyscript.net/latest/+../../../build/+g {} \;
find ./examples -type f -name '*.html' -exec sed -i s+https://pyscript.net/latest/+../build/+g {} \;
npm run build

> pyscript@0.0.1 build
> npm run tsc && node esbuild.mjs


> pyscript@0.0.1 tsc
> tsc --noEmit

[1mpyscript[0m [2m(prod)[0m built in: 86.239ms
rm -rf ./examples/build
mkdir -p ./examples/build
cp -R ./build/* ./examples/build
To serve examples run: conda run -p /home/jglass/Documents/pyscript/pyscriptjs/env python -m http.server 8080 --directory examples
make[2]: Leaving directory '/home/jglass/Documents/pyscript/pyscriptjs'
mkdir -p test_results
/home/jglass/Documents/pyscript/pyscriptjs/env/bin/pytest --numprocesses auto -vv  tests/integration/ --log-cli-level=warning --junitxml=test_results/integration.xml --instafail --random-order-bucket=global
gw0 I / gw1 I / gw2 I / gw3 I / gw4 I / gw5 I / gw6 I / gw7 I
[gw0] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw1] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw2] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw3] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw4] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw5] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw6] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
[gw7] linux Python 3.11.0 cwd: /home/jglass/Documents/pyscript/pyscriptjs
============================= test session starts ==============================
platform linux -- Python 3.11.0, pytest-7.1.2, pluggy-1.0.0 -- /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python
cachedir: .pytest_cache
Using --random-order-bucket=global
Using --random-order-seed=371994

rootdir: /home/jglass/Documents/pyscript/pyscriptjs
plugins: random-order-1.1.0, base-url-2.0.0, playwright-0.3.2, xdist-3.2.1, instafail-0.5.0
collecting ... [gw0] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw1] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw2] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw4] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw3] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw6] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw5] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
[gw7] Python 3.11.0 (main, Jan 16 2023, 14:19:54) [GCC 11.2.0]
gw0 [191] / gw1 [191] / gw2 [191] / gw3 [191] / gw4 [191] / gw5 [191] / gw6 [191] / gw7 [191]

scheduling tests via LoadScheduling

tests/integration/test_02_display.py::TestOutput::test_no_implicit_target[chromium] 
tests/integration/test_00_support.py::TestSupport::test_wait_for_console_simple[chromium] 
tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_closes_on_error_with_pys_onClick[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_dynamically_add_py_script_tag[chromium] 
[gw3] [  0%] SKIPPED tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_closes_on_error_with_pys_onClick[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_python_exception_after_previous_output[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_py_attribute_without_id[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_py_script_src_attribute[chromium] 
tests/integration/test_00_support.py::TestSupport::test_check_js_errors_some_expected_but_others_not[chromium] 
tests/integration/test_py_config.py::TestConfig::test_invalid_json_config[chromium] 
[gw5] [  1%] PASSED tests/integration/test_00_support.py::TestSupport::test_check_js_errors_some_expected_but_others_not[chromium] 
tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_guides_asyncio[chromium] 
[gw7] [  1%] PASSED tests/integration/test_00_support.py::TestSupport::test_wait_for_console_simple[chromium] 
tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected_but_didnt_raise[chromium] 
[gw0] [  2%] PASSED tests/integration/test_py_config.py::TestConfig::test_invalid_json_config[chromium] 
tests/integration/test_02_display.py::TestOutput::test_append_true[chromium] 
[gw7] [  2%] PASSED tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected_but_didnt_raise[chromium] 
tests/integration/test_py_config.py::TestConfig::test_paths[chromium] 
[gw5] [  3%] PASSED tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_guides_asyncio[chromium] 
tests/integration/test_py_terminal.py::TestPyTerminal::test_two_terminals[chromium] 
[gw6] [  3%] PASSED tests/integration/test_01_basic.py::TestBasic::test_py_script_src_attribute[chromium] 
[gw4] [  4%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_python_exception_after_previous_output[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_src_path_that_do_not_exist[chromium] 
tests/integration/test_plugins.py::TestPlugin::test_no_plugin_attribute_error[chromium] 
[gw2] [  4%] PASSED tests/integration/test_02_display.py::TestOutput::test_no_implicit_target[chromium] 
tests/integration/test_00_support.py::TestSupport::test_basic[chromium] 
[gw3] [  5%] PASSED tests/integration/test_01_basic.py::TestBasic::test_py_attribute_without_id[chromium] 
[gw7] [  5%] PASSED tests/integration/test_py_config.py::TestConfig::test_paths[chromium] 
tests/integration/test_02_display.py::TestOutput::test_append_false[chromium] 
tests/integration/test_02_display.py::TestOutput::test_console_line_break[chromium] 
[gw0] [  6%] PASSED tests/integration/test_02_display.py::TestOutput::test_append_true[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_write_append[chromium] 
[gw1] [  6%] PASSED tests/integration/test_01_basic.py::TestBasic::test_dynamically_add_py_script_tag[chromium] 
tests/integration/test_py_config.py::TestConfig::test_py_config_inline[chromium] 
[gw2] [  7%] PASSED tests/integration/test_00_support.py::TestSupport::test_basic[chromium] 
tests/integration/test_02_display.py::TestOutput::test_display_multiple_append_false[chromium] 
[gw1] [  7%] PASSED tests/integration/test_py_config.py::TestConfig::test_py_config_inline[chromium] 
tests/integration/test_interpreter.py::TestInterpreterAccess::test_backward_compatibility_runtime_python_access[chromium] 
[gw0] [  8%] PASSED tests/integration/test_03_element.py::TestElement::test_element_write_append[chromium] 
[gw4] [  8%] PASSED tests/integration/test_plugins.py::TestPlugin::test_no_plugin_attribute_error[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_run_clears_previous_output[chromium] 
tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_custom_message[chromium] 
[gw6] [  9%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_src_path_that_do_not_exist[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_element_id_change[chromium] 
[gw7] [  9%] PASSED tests/integration/test_02_display.py::TestOutput::test_append_false[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_simple_clock[chromium] 
[gw2] [ 10%] PASSED tests/integration/test_02_display.py::TestOutput::test_display_multiple_append_false[chromium] 
tests/integration/test_splashscreen.py::TestSplashscreen::test_autoshow_and_autoclose[chromium] 
[gw3] [ 10%] PASSED tests/integration/test_02_display.py::TestOutput::test_console_line_break[chromium] 
[gw5] [ 11%] PASSED tests/integration/test_py_terminal.py::TestPyTerminal::test_two_terminals[chromium] 
tests/integration/test_style.py::TestStyle::test_pyscript_defined[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_id[chromium] 
[gw2] [ 12%] PASSED tests/integration/test_splashscreen.py::TestSplashscreen::test_autoshow_and_autoclose[chromium] 
tests/integration/test_00_support.py::TestSupport::test_wait_for_console_timeout[chromium] 
[gw5] [ 12%] PASSED tests/integration/test_03_element.py::TestElement::test_element_id[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_add_multiple_class[chromium] 
[gw1] [ 13%] PASSED tests/integration/test_interpreter.py::TestInterpreterAccess::test_backward_compatibility_runtime_python_access[chromium] 
tests/integration/test_02_display.py::TestOutput::test_display_should_escape[chromium] 
[gw4] [ 13%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_run_clears_previous_output[chromium] 
tests/integration/test_00_support.py::TestSupport::test_404[chromium] 
[gw6] [ 14%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_element_id_change[chromium] 
[gw4] [ 14%] PASSED tests/integration/test_00_support.py::TestSupport::test_404[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_remove_single_class[chromium] 
tests/integration/test_02_display.py::TestOutput::test_implicit_target_from_a_different_tag[chromium] 
[gw0] [ 15%] PASSED tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_custom_message[chromium] 
[gw2] [ 15%] PASSED tests/integration/test_00_support.py::TestSupport::test_wait_for_console_timeout[chromium] 
tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected_not_found_but_other_errors[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_load_content_from_src[chromium] 
[gw0] [ 16%] PASSED tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected_not_found_but_other_errors[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_clone_no_id[chromium] 
[gw3] [ 16%] PASSED tests/integration/test_style.py::TestStyle::test_pyscript_defined[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_non_existent_package[chromium] 
[gw7] [ 17%] PASSED tests/integration/test_zz_examples.py::TestExamples::test_simple_clock[chromium] 
tests/integration/test_py_config.py::TestConfig::test_py_config_external[chromium] 
[gw5] [ 17%] PASSED tests/integration/test_03_element.py::TestElement::test_element_add_multiple_class[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_panel_stream[chromium] 
[gw1] [ 18%] PASSED tests/integration/test_02_display.py::TestOutput::test_display_should_escape[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_value[chromium] 
[gw6] [ 18%] PASSED tests/integration/test_02_display.py::TestOutput::test_implicit_target_from_a_different_tag[chromium] 
tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_writing_to_page[chromium] 
[gw2] [ 19%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_load_content_from_src[chromium] 
[gw4] [ 19%] PASSED tests/integration/test_03_element.py::TestElement::test_element_remove_single_class[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_src_change[chromium] 
tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_py_config_fetch[chromium] 
[gw0] [ 20%] PASSED tests/integration/test_03_element.py::TestElement::test_element_clone_no_id[chromium] 
tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_target_element_id_change[chromium] 
[gw3] [ 20%] PASSED tests/integration/test_01_basic.py::TestBasic::test_non_existent_package[chromium] 
tests/integration/test_py_terminal.py::TestPyTerminal::test_config_auto[chromium] 
[gw7] [ 21%] PASSED tests/integration/test_py_config.py::TestConfig::test_py_config_external[chromium] 
tests/integration/test_plugins.py::TestPlugin::test_fetch_js_no_export[chromium] 
[gw1] [ 21%] PASSED tests/integration/test_03_element.py::TestElement::test_element_value[chromium] 
tests/integration/test_importmap.py::TestImportmap::test_importmap[chromium] 
[gw6] [ 22%] PASSED tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_writing_to_page[chromium] 
[gw2] [ 23%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_src_change[chromium] 
tests/integration/test_plugins.py::TestPlugin::test_py_plugin_inline[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_hello_world[chromium] 
[gw0] [ 23%] PASSED tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_target_element_id_change[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_attribute_change[chromium] 
[gw3] [ 24%] PASSED tests/integration/test_py_terminal.py::TestPyTerminal::test_config_auto[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_display[chromium] 
[gw4] [ 24%] PASSED tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_py_config_fetch[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_pys_onClick_shows_deprecation_warning[chromium] 
[gw4] [ 25%] SKIPPED tests/integration/test_01_basic.py::TestBasic::test_pys_onClick_shows_deprecation_warning[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_panel_deckgl[chromium] 
[gw7] [ 25%] PASSED tests/integration/test_plugins.py::TestPlugin::test_fetch_js_no_export[chromium] 
tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin[chromium] 
[gw1] [ 26%] XFAIL tests/integration/test_importmap.py::TestImportmap::test_importmap[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_auto_generate[chromium] 
[gw2] [ 26%] PASSED tests/integration/test_zz_examples.py::TestExamples::test_hello_world[chromium] 
tests/integration/test_02_display.py::TestOutput::test_explicit_different_target_from_call[chromium] 
[gw6] [ 27%] PASSED tests/integration/test_plugins.py::TestPlugin::test_py_plugin_inline[chromium] 
tests/integration/test_02_display.py::TestOutput::test_explicit_target_pyscript_tag[chromium] 
[gw0] [ 27%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_attribute_change[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_bokeh_interactive[chromium] 
[gw3] [ 28%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_display[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_py_script_src_not_found[chromium] 
[gw7] [ 28%] PASSED tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin[chromium] 
tests/integration/test_03_element.py::TestElement::test_element_clear_div[chromium] 
[gw1] [ 29%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_auto_generate[chromium] 
tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_requests[chromium] 
[gw6] [ 29%] PASSED tests/integration/test_02_display.py::TestOutput::test_explicit_target_pyscript_tag[chromium] 
tests/integration/test_02_display.py::TestOutput::test_consecutive_display[chromium] 
[gw2] [ 30%] PASSED tests/integration/test_02_display.py::TestOutput::test_explicit_different_target_from_call[chromium] 
tests/integration/test_splashscreen.py::TestSplashscreen::test_autoclose_false[chromium] 
[gw3] [ 30%] PASSED tests/integration/test_01_basic.py::TestBasic::test_py_script_src_not_found[chromium] 
tests/integration/test_00_support.py::TestSupport::test_clear_js_errors[chromium] 
[gw3] [ 31%] PASSED tests/integration/test_00_support.py::TestSupport::test_clear_js_errors[chromium] 
tests/integration/test_warnings_and_banners.py::TestWarningsAndBanners::test_create_singular_warning[chromium] 
[gw7] [ 31%] PASSED tests/integration/test_03_element.py::TestElement::test_element_clear_div[chromium] 
tests/integration/test_async.py::TestAsync::test_multiple_async_multiple_display_targeted[chromium] 
[gw6] [ 32%] PASSED tests/integration/test_02_display.py::TestOutput::test_consecutive_display[chromium] 
tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_solo[chromium] 
[gw2] [ 32%] PASSED tests/integration/test_splashscreen.py::TestSplashscreen::test_autoclose_false[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_multiple_repls_mixed_display_order[chromium] 
[gw1] [ 33%] PASSED tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_requests[chromium] 
tests/integration/test_py_config.py::TestConfig::test_no_interpreter[chromium] 
[gw0] [ 34%] PASSED tests/integration/test_zz_examples.py::TestExamples::test_bokeh_interactive[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_attribute[chromium] 
[gw1] [ 34%] PASSED tests/integration/test_py_config.py::TestConfig::test_no_interpreter[chromium] 
tests/integration/test_02_display.py::TestOutput::test_multiple_display_calls_same_tag[chromium] 
[gw3] [ 35%] PASSED tests/integration/test_warnings_and_banners.py::TestWarningsAndBanners::test_create_singular_warning[chromium] 
tests/integration/test_interpreter.py::TestInterpreterAccess::test_interpreter_python_access[chromium] 
[gw7] [ 35%] PASSED tests/integration/test_async.py::TestAsync::test_multiple_async_multiple_display_targeted[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_escaping_of_angle_brackets[chromium] 
[gw6] [ 36%] PASSED tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_solo[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_assert_no_banners[chromium] 
[gw2] [ 36%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_multiple_repls_mixed_display_order[chromium] 
tests/integration/test_py_terminal.py::TestPyTerminal::test_config_true[chromium] 
[gw0] [ 37%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_attribute[chromium] 
tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_interleaved[chromium] 
[gw1] [ 37%] PASSED tests/integration/test_02_display.py::TestOutput::test_multiple_display_calls_same_tag[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_stderr_id_errors[chromium] 
[gw3] [ 38%] PASSED tests/integration/test_interpreter.py::TestInterpreterAccess::test_interpreter_python_access[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_show_last_expression_with_output[chromium] 
[gw7] [ 38%] PASSED tests/integration/test_01_basic.py::TestBasic::test_escaping_of_angle_brackets[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_hide_previous_error_after_successful_run[chromium] 
[gw6] [ 39%] PASSED tests/integration/test_01_basic.py::TestBasic::test_assert_no_banners[chromium] 
tests/integration/test_00_support.py::TestSupport::test_wait_for_console_exception_2[chromium] 
[gw6] [ 39%] PASSED tests/integration/test_00_support.py::TestSupport::test_wait_for_console_exception_2[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_execute_code_typed_by_the_user[chromium] 
[gw2] [ 40%] PASSED tests/integration/test_py_terminal.py::TestPyTerminal::test_config_true[chromium] 
tests/integration/test_importmap.py::TestImportmap::test_invalid_json[chromium] 
[gw0] [ 40%] PASSED tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_interleaved[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_panel[chromium] 
[gw1] [ 41%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_stderr_id_errors[chromium] 
tests/integration/test_02_display.py::TestOutput::test_empty_HTML_and_console_output[chromium] 
[gw3] [ 41%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_show_last_expression_with_output[chromium] 
tests/integration/test_style.py::TestStyle::test_pyscript_not_defined[chromium] 
[gw3] [ 42%] PASSED tests/integration/test_style.py::TestStyle::test_pyscript_not_defined[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_execute_preloaded_source[chromium] 
[gw7] [ 42%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_hide_previous_error_after_successful_run[chromium] 
tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_py_click[chromium] 
[gw4] [ 43%] PASSED tests/integration/test_zz_examples.py::TestExamples::test_panel_deckgl[chromium] 
tests/integration/test_py_config.py::TestConfig::test_paths_from_packages[chromium] 
[gw2] [ 43%] XPASS tests/integration/test_importmap.py::TestImportmap::test_invalid_json[chromium] 
tests/integration/test_async.py::TestAsync::test_sync_and_async_order[chromium] 
[gw6] [ 44%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_execute_code_typed_by_the_user[chromium] 
tests/integration/test_async.py::TestAsync::test_asyncio_create_task[chromium] 
[gw1] [ 45%] PASSED tests/integration/test_02_display.py::TestOutput::test_empty_HTML_and_console_output[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_js_version[chromium] 
[gw7] [ 45%] PASSED tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_py_click[chromium] 
[gw3] [ 46%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_execute_preloaded_source[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_todo_pylist[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_show_last_expression[chromium] 
[gw2] [ 46%] PASSED tests/integration/test_async.py::TestAsync::test_sync_and_async_order[chromium] 
tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_py_config_interpreter[chromium] 
[gw6] [ 47%] PASSED tests/integration/test_async.py::TestAsync::test_asyncio_create_task[chromium] 
tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_stdout_id_errors[chromium] 
[gw1] [ 47%] PASSED tests/integration/test_01_basic.py::TestBasic::test_js_version[chromium] 
tests/integration/test_02_display.py::TestOutput::test_image_renders_correctly[chromium] 
[gw3] [ 48%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_show_last_expression[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_execution_in_order[chromium] 
[gw7] [ 48%] XPASS tests/integration/test_zz_examples.py::TestExamples::test_todo_pylist[chromium] 
[gw7] [ 48%] XFAIL tests/integration/test_zz_examples.py::TestExamples::test_todo_pylist[chromium] 
tests/integration/test_02_display.py::TestOutput::test_consecutive_display_target[chromium] 
[gw4] [ 49%] PASSED tests/integration/test_py_config.py::TestConfig::test_paths_from_packages[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_python_exception[chromium] 
[gw2] [ 49%] PASSED tests/integration/test_zzz_docs_snippets.py::TestDocsSnippets::test_tutorials_py_config_interpreter[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_numpy_canvas_fractals[chromium] 
[gw6] [ 50%] PASSED tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_stdout_id_errors[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_py_mount_shows_deprecation_warning[chromium] 
[gw1] [ 50%] PASSED tests/integration/test_02_display.py::TestOutput::test_image_renders_correctly[chromium] 
tests/integration/test_py_repl.py::TestPyRepl::test_repl_loads[chromium] 
[gw7] [ 51%] PASSED tests/integration/test_02_display.py::TestOutput::test_consecutive_display_target[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_repl2[chromium] 
[gw3] [ 51%] PASSED tests/integration/test_01_basic.py::TestBasic::test_execution_in_order[chromium] 
tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin_bare[chromium] 
[gw4] [ 52%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_python_exception[chromium] 
tests/integration/test_02_display.py::TestOutput::test_display_HTML[chromium] 
[gw6] [ 52%] PASSED tests/integration/test_01_basic.py::TestBasic::test_py_mount_shows_deprecation_warning[chromium] 
tests/integration/test_async.py::TestAsync::test_multiple_async[chromium] 
[gw1] [ 53%] PASSED tests/integration/test_py_repl.py::TestPyRepl::test_repl_loads[chromium] 
tests/integration/test_02_display.py::TestOutput::test_text_HTML_and_console_output[chromium] 
[gw3] [ 53%] PASSED tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin_bare[chromium] 
tests/integration/test_zz_examples.py::TestExamples::test_toga_freedom[chromium] 
[gw4] [ 54%] FAILED tests/integration/test_02_display.py::TestOutput::test_display_HTML[chromium] 
____________________ TestOutput.test_display_HTML[chromium] ____________________
[gw4] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7fd9c7f71610>

    def test_display_HTML(self):
>       self.pyscript_run(
            """
            <py-script>
                display(HTML("<p>hello world</p>"))
            </py-script>
            """
        )

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/test_02_display.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:320: in pyscript_run
    self.wait_for_pyscript(timeout=timeout)
/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:274: in wait_for_pyscript
    elapsed_ms = self.wait_for_console(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_02_display.TestOutput object at 0x7fd9c7f71610>
text = '[pyscript/main] PyScript page fully initialized'

    def wait_for_console(self, text, *, timeout=None, check_js_errors=True):
        """
        Wait until the given message appear in the console. If the message was
        already printed in the console, return immediately.
    
        Note: it must be the *exact* string as printed by e.g. console.log.
    
        timeout is expressed in milliseconds. If it's None, it will use
        the same default as playwright, which is 30 seconds.
    
        If check_js_errors is True (the default), it also checks that no JS
        errors were raised during the waiting.
    
        Return the elapsed time in ms.
        """
        if timeout is None:
            timeout = 30 * 1000
        # NOTE: we cannot use playwright's own page.expect_console_message(),
        # because if you call it AFTER the text has already been emitted, it
        # waits forever. Instead, we have to use our own custom logic.
        try:
            t0 = time.time()
            while True:
                elapsed_ms = (time.time() - t0) * 1000
                if elapsed_ms > timeout:
>                   raise TimeoutError(f"{elapsed_ms:.2f} ms")
E                   TimeoutError: 31801.28 ms

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:247: TimeoutError
---------------------------- Captured stdout setup -----------------------------

----------------------------- Captured stdout call -----------------------------
[33;01m[  0.00 page.goto        ] display_HTML.html[00m
[34;01m[  0.01 request          ] 200 - fake_server - http://fake_server/display_HTML.html[00m
[34;01m[  0.03 request          ] 200 - fake_server - http://fake_server/build/pyscript.css[00m
[34;01m[  0.04 request          ] 200 - fake_server - http://fake_server/build/pyscript.js[00m
[  0.20 console.info     ] [36m[pyscript/main][00m searching for <py-config>
[  0.20 console.info     ] [36m[pyscript/main][00m config loaded:
{
  "schema_version": 1,
  "type": "app",
  "interpreters": [
    {
      "src": "https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js",
      "name": "pyodide-0.23.0",
      "lang": "python"
    }
  ],
  "runtimes": [],
  "packages": [],
  "fetch": [],
  "plugins": [],
  "pyscript": {
    "version": "2022.12.1.dev",
    "time": "2023-04-13T17:23:50.231Z"
  }
}
[  0.20 console.info     ] [36m[py-splashscreen][00m add py-splashscreen
[  0.20 console.info     ] [36m[py-terminal][00m No <py-terminal> found, adding one
[  0.20 console.info     ] [36m[pyscript/main][00m Initializing interpreter
[  0.20 console.info     ] [36m[pyscript/main][00m Downloading pyodide-0.23.0...
[34;01m[  0.22 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js[00m
[  0.23 console.info     ] [36m[pyscript/main][00m Python startup...
[34;01m[  0.26 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/python_stdlib.zip[00m
[34;01m[  0.34 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.asm.js[00m
[34;01m[  1.07 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/repodata.json[00m
[34;01m[  1.26 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.asm.wasm[00m
[gw6] [ 54%] FAILED tests/integration/test_async.py::TestAsync::test_multiple_async[chromium] 
___________________ TestAsync.test_multiple_async[chromium] ____________________
[gw6] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_async.TestAsync object at 0x7feb7b1c8b90>

    def test_multiple_async(self):
>       self.pyscript_run(
            """
        <py-script>
            import js
            import asyncio
            async def a_func():
                for i in range(3):
                    js.console.log('A', i)
                    await asyncio.sleep(0.1)
            asyncio.ensure_future(a_func())
        </py-script>
    
        <py-script>
            import js
            import asyncio
            async def b_func():
                for i in range(3):
                    js.console.log('B', i)
                    await asyncio.sleep(0.1)
                js.console.log('b func done')
            asyncio.ensure_future(b_func())
        </py-script>
        """
        )

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/test_async.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:320: in pyscript_run
    self.wait_for_pyscript(timeout=timeout)
/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:274: in wait_for_pyscript
    elapsed_ms = self.wait_for_console(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_async.TestAsync object at 0x7feb7b1c8b90>
text = '[pyscript/main] PyScript page fully initialized'

    def wait_for_console(self, text, *, timeout=None, check_js_errors=True):
        """
        Wait until the given message appear in the console. If the message was
        already printed in the console, return immediately.
    
        Note: it must be the *exact* string as printed by e.g. console.log.
    
        timeout is expressed in milliseconds. If it's None, it will use
        the same default as playwright, which is 30 seconds.
    
        If check_js_errors is True (the default), it also checks that no JS
        errors were raised during the waiting.
    
        Return the elapsed time in ms.
        """
        if timeout is None:
            timeout = 30 * 1000
        # NOTE: we cannot use playwright's own page.expect_console_message(),
        # because if you call it AFTER the text has already been emitted, it
        # waits forever. Instead, we have to use our own custom logic.
        try:
            t0 = time.time()
            while True:
                elapsed_ms = (time.time() - t0) * 1000
                if elapsed_ms > timeout:
>                   raise TimeoutError(f"{elapsed_ms:.2f} ms")
E                   TimeoutError: 30583.64 ms

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:247: TimeoutError
---------------------------- Captured stdout setup -----------------------------

----------------------------- Captured stdout call -----------------------------
[33;01m[  0.00 page.goto        ] multiple_async.html[00m
[34;01m[  0.02 request          ] 200 - fake_server - http://fake_server/multiple_async.html[00m
[34;01m[  0.04 request          ] 200 - fake_server - http://fake_server/build/pyscript.css[00m
[34;01m[  0.04 request          ] 200 - fake_server - http://fake_server/build/pyscript.js[00m
[  0.21 console.info     ] [36m[pyscript/main][00m searching for <py-config>
[  0.22 console.info     ] [36m[pyscript/main][00m config loaded:
{
  "schema_version": 1,
  "type": "app",
  "interpreters": [
    {
      "src": "https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js",
      "name": "pyodide-0.23.0",
      "lang": "python"
    }
  ],
  "runtimes": [],
  "packages": [],
  "fetch": [],
  "plugins": [],
  "pyscript": {
    "version": "2022.12.1.dev",
    "time": "2023-04-13T17:23:51.448Z"
  }
}
[  0.22 console.info     ] [36m[py-splashscreen][00m add py-splashscreen
[  0.22 console.info     ] [36m[py-terminal][00m No <py-terminal> found, adding one
[  0.22 console.info     ] [36m[pyscript/main][00m Initializing interpreter
[  0.22 console.info     ] [36m[pyscript/main][00m Downloading pyodide-0.23.0...
[34;01m[  0.24 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js[00m
[  0.25 console.info     ] [36m[pyscript/main][00m Python startup...
[34;01m[  0.29 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/python_stdlib.zip[00m
[34;01m[  0.38 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.asm.js[00m
[34;01m[  1.42 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/repodata.json[00m
[34;01m[  1.66 request          ] 200 - CACHED - https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.asm.wasm[00m

tests/integration/test_03_element.py::TestElement::test_element_write_no_append[chromium] 
tests/integration/test_00_support.py::TestSupport::test_await_with_run_js[chromium] 
[gw1] [ 55%] FAILED tests/integration/test_02_display.py::TestOutput::test_text_HTML_and_console_output[chromium] 
____________ TestOutput.test_text_HTML_and_console_output[chromium] ____________
[gw1] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7f429d15e2d0>

    def test_text_HTML_and_console_output(self):
>       self.pyscript_run(
            """
            <py-script>
                display('this goes to the DOM')
                print('print from python')
                console.log('print from js')
                console.error('error from js');
            </py-script>
        """
        )

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/test_02_display.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:318: in pyscript_run
    self.goto(filename)
/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:220: in goto
    self.page.goto(url, timeout=0)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:9221: in goto
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_page.py:495: in goto
    return await self._main_frame.goto(**locals_to_params(locals()))
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_frame.py:147: in goto
    await self._channel.send("goto", locals_to_params(locals()))
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7f4298267710>
method = 'goto'
params = {'timeout': 0, 'url': 'http://fake_server/text_HTML_and_console_output.html'}
return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: net::ERR_ABORTED; maybe frame was detached?
E       =========================== logs ===========================
E       navigating to "http://fake_server/text_HTML_and_console_output.html", waiting until "load"
E       ============================================================

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
---------------------------- Captured stdout setup -----------------------------

----------------------------- Captured stdout call -----------------------------
[33;01m[  0.00 page.goto        ] text_HTML_and_console_output.html[00m
[34;01m[  0.13 request          ] 200 - fake_server - http://fake_server/text_HTML_and_console_output.html[00m

tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_stderr_id_errors[chromium] 
[gw3] [ 56%] XFAIL tests/integration/test_zz_examples.py::TestExamples::test_toga_freedom[chromium] 
[gw3] [ 56%] XFAIL tests/integration/test_zz_examples.py::TestExamples::test_toga_freedom[chromium] 
tests/integration/test_01_basic.py::TestBasic::test_getPySrc_returns_source_code[chromium] 
[gw3] [ 56%] ERROR tests/integration/test_01_basic.py::TestBasic::test_getPySrc_returns_source_code[chromium] 
___ ERROR at setup of TestBasic.test_getPySrc_returns_source_code[chromium] ____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_getPySrc_returns_source_code[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 56%] ERROR tests/integration/test_01_basic.py::TestBasic::test_getPySrc_returns_source_code[chromium] 
__ ERROR at teardown of TestBasic.test_getPySrc_returns_source_code[chromium] __
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36eac3610>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36eac3610>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_01_basic.py::TestBasic::test_pyscript_hello[chromium] 
[gw3] [ 57%] ERROR tests/integration/test_01_basic.py::TestBasic::test_pyscript_hello[chromium] 
__________ ERROR at setup of TestBasic.test_pyscript_hello[chromium] ___________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_pyscript_hello[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 57%] ERROR tests/integration/test_01_basic.py::TestBasic::test_pyscript_hello[chromium] 
_________ ERROR at teardown of TestBasic.test_pyscript_hello[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ece90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ece90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_config.py::TestConfig::test_runtime_still_works_but_shows_deprecation_warning[chromium] 
[gw3] [ 57%] ERROR tests/integration/test_py_config.py::TestConfig::test_runtime_still_works_but_shows_deprecation_warning[chromium] 
_ ERROR at setup of TestConfig.test_runtime_still_works_but_shows_deprecation_warning[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_runtime_still_works_but_shows_deprecation_warning[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw4] [ 58%] PASSED tests/integration/test_00_support.py::TestSupport::test_await_with_run_js[chromium] 
[gw3] [ 58%] ERROR tests/integration/test_py_config.py::TestConfig::test_runtime_still_works_but_shows_deprecation_warning[chromium] 
_ ERROR at teardown of TestConfig.test_runtime_still_works_but_shows_deprecation_warning[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_config.TestConfig object at 0x7fb367f08150>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_config.TestConfig object at 0x7fb367f08150>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestConfig' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_00_support.py::TestSupport::test_wait_for_console_exception_1[chromium] 
tests/integration/test_interpreter.py::TestInterpreterAccess::test_backward_compatibility_runtime_script_execution[chromium] 
[gw3] [ 58%] ERROR tests/integration/test_00_support.py::TestSupport::test_wait_for_console_exception_1[chromium] 
__ ERROR at setup of TestSupport.test_wait_for_console_exception_1[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_wait_for_console_exception_1[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 58%] ERROR tests/integration/test_00_support.py::TestSupport::test_wait_for_console_exception_1[chromium] 
_ ERROR at teardown of TestSupport.test_wait_for_console_exception_1[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_00_support.TestSupport object at 0x7fb36e88b3d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_00_support.TestSupport object at 0x7fb36e88b3d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSupport' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_config.py::TestConfig::test_interpreter_config[chromium] 
[gw3] [ 59%] ERROR tests/integration/test_py_config.py::TestConfig::test_interpreter_config[chromium] 
________ ERROR at setup of TestConfig.test_interpreter_config[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_interpreter_config[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 59%] ERROR tests/integration/test_py_config.py::TestConfig::test_interpreter_config[chromium] 
______ ERROR at teardown of TestConfig.test_interpreter_config[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_config.TestConfig object at 0x7fb36c13b810>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_config.TestConfig object at 0x7fb36c13b810>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestConfig' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_03_element.py::TestElement::test_element_innerHtml[chromium] 
[gw3] [ 59%] ERROR tests/integration/test_03_element.py::TestElement::test_element_innerHtml[chromium] 
________ ERROR at setup of TestElement.test_element_innerHtml[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_element_innerHtml[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 59%] ERROR tests/integration/test_03_element.py::TestElement::test_element_innerHtml[chromium] 
______ ERROR at teardown of TestElement.test_element_innerHtml[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_03_element.TestElement object at 0x7fb36c57e1d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_03_element.TestElement object at 0x7fb36c57e1d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestElement' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_00_support.py::TestSupport::test_smartrouter_cache[chromium] 
[gw3] [ 60%] ERROR tests/integration/test_00_support.py::TestSupport::test_smartrouter_cache[chromium] 
________ ERROR at setup of TestSupport.test_smartrouter_cache[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_smartrouter_cache[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 60%] ERROR tests/integration/test_00_support.py::TestSupport::test_smartrouter_cache[chromium] 
______ ERROR at teardown of TestSupport.test_smartrouter_cache[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_00_support.TestSupport object at 0x7fb36e88b690>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_00_support.TestSupport object at 0x7fb36e88b690>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSupport' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_terminal.py::TestPyTerminal::test_auto_attribute[chromium] 
[gw3] [ 60%] ERROR tests/integration/test_py_terminal.py::TestPyTerminal::test_auto_attribute[chromium] 
________ ERROR at setup of TestPyTerminal.test_auto_attribute[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_auto_attribute[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 60%] ERROR tests/integration/test_py_terminal.py::TestPyTerminal::test_auto_attribute[chromium] 
______ ERROR at teardown of TestPyTerminal.test_auto_attribute[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_terminal.TestPyTerminal object at 0x7fb367f429d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_terminal.TestPyTerminal object at 0x7fb367f429d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyTerminal' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_02_display.py::TestOutput::test_explicit_target_on_button_tag[chromium] 
[gw3] [ 61%] ERROR tests/integration/test_02_display.py::TestOutput::test_explicit_target_on_button_tag[chromium] 
__ ERROR at setup of TestOutput.test_explicit_target_on_button_tag[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_explicit_target_on_button_tag[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 61%] ERROR tests/integration/test_02_display.py::TestOutput::test_explicit_target_on_button_tag[chromium] 
_ ERROR at teardown of TestOutput.test_explicit_target_on_button_tag[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7fb36c55d290>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_02_display.TestOutput object at 0x7fb36c55d290>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutput' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_01_basic.py::TestBasic::test_python_exception_in_event_handler[chromium] 
[gw3] [ 61%] ERROR tests/integration/test_01_basic.py::TestBasic::test_python_exception_in_event_handler[chromium] 
_ ERROR at setup of TestBasic.test_python_exception_in_event_handler[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_python_exception_in_event_handler[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 61%] ERROR tests/integration/test_01_basic.py::TestBasic::test_python_exception_in_event_handler[chromium] 
_ ERROR at teardown of TestBasic.test_python_exception_in_event_handler[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ed310>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ed310>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_output_attribute_change[chromium] 
[gw3] [ 62%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_output_attribute_change[chromium] 
_ ERROR at setup of TestOutputHandling.test_stdio_output_attribute_change[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_stdio_output_attribute_change[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 62%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_output_attribute_change[chromium] 
_ ERROR at teardown of TestOutputHandling.test_stdio_output_attribute_change[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f69010>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f69010>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutputHandling' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_01_basic.py::TestBasic::test_python_exception[chromium] 
[gw3] [ 62%] ERROR tests/integration/test_01_basic.py::TestBasic::test_python_exception[chromium] 
_________ ERROR at setup of TestBasic.test_python_exception[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_python_exception[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 62%] ERROR tests/integration/test_01_basic.py::TestBasic::test_python_exception[chromium] 
________ ERROR at teardown of TestBasic.test_python_exception[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ed050>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ed050>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_terminal.py::TestPyTerminal::test_config_docked[chromium] 
[gw3] [ 63%] ERROR tests/integration/test_py_terminal.py::TestPyTerminal::test_config_docked[chromium] 
________ ERROR at setup of TestPyTerminal.test_config_docked[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_config_docked[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 63%] ERROR tests/integration/test_py_terminal.py::TestPyTerminal::test_config_docked[chromium] 
_______ ERROR at teardown of TestPyTerminal.test_config_docked[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_terminal.TestPyTerminal object at 0x7fb367f50290>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_terminal.TestPyTerminal object at 0x7fb367f50290>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyTerminal' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_stderr[chromium] 
[gw3] [ 63%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_stderr[chromium] 
_______ ERROR at setup of TestOutputHandling.test_stdio_stderr[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_stdio_stderr[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 63%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_stderr[chromium] 
_____ ERROR at teardown of TestOutputHandling.test_stdio_stderr[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f687d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f687d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutputHandling' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_repl.py::TestPyRepl::test_repl_stdio_dynamic_tags[chromium] 
[gw3] [ 64%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_repl_stdio_dynamic_tags[chromium] 
_____ ERROR at setup of TestPyRepl.test_repl_stdio_dynamic_tags[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_repl_stdio_dynamic_tags[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 64%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_repl_stdio_dynamic_tags[chromium] 
____ ERROR at teardown of TestPyRepl.test_repl_stdio_dynamic_tags[chromium] ____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f39610>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f39610>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyRepl' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_repl[chromium] 
[gw3] [ 64%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_repl[chromium] 
______________ ERROR at setup of TestExamples.test_repl[chromium] ______________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_repl[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 64%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_repl[chromium] 
____________ ERROR at teardown of TestExamples.test_repl[chromium] _____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c396f90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c396f90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_async[chromium] 
[gw3] [ 65%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_async[chromium] 
___ ERROR at setup of TestOutputHandling.test_targeted_stdio_async[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_targeted_stdio_async[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 65%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_async[chromium] 
_ ERROR at teardown of TestOutputHandling.test_targeted_stdio_async[chromium] __
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f5e5d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f5e5d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutputHandling' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_escape[chromium] 
[gw3] [ 65%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_escape[chromium] 
_______ ERROR at setup of TestOutputHandling.test_stdio_escape[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_stdio_escape[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 65%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_stdio_escape[chromium] 
_____ ERROR at teardown of TestOutputHandling.test_stdio_escape[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f5dbd0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f5dbd0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutputHandling' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_splashscreen.py::TestSplashscreen::test_autoclose_loader_deprecated[chromium] 
[gw3] [ 66%] ERROR tests/integration/test_splashscreen.py::TestSplashscreen::test_autoclose_loader_deprecated[chromium] 
_ ERROR at setup of TestSplashscreen.test_autoclose_loader_deprecated[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_autoclose_loader_deprecated[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 66%] ERROR tests/integration/test_splashscreen.py::TestSplashscreen::test_autoclose_loader_deprecated[chromium] 
_ ERROR at teardown of TestSplashscreen.test_autoclose_loader_deprecated[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_splashscreen.TestSplashscreen object at 0x7fb367f520d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_splashscreen.TestSplashscreen object at 0x7fb367f520d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSplashscreen' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_02_display.py::TestOutput::test_display_multiple_append_false_with_target[chromium] 
[gw3] [ 67%] ERROR tests/integration/test_02_display.py::TestOutput::test_display_multiple_append_false_with_target[chromium] 
_ ERROR at setup of TestOutput.test_display_multiple_append_false_with_target[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_display_multiple_append_false_with_target[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 67%] ERROR tests/integration/test_02_display.py::TestOutput::test_display_multiple_append_false_with_target[chromium] 
_ ERROR at teardown of TestOutput.test_display_multiple_append_false_with_target[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7fb36c570950>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_02_display.TestOutput object at 0x7fb36c570950>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutput' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_plugins.py::TestPlugin::test_execution_hooks[chromium] 
[gw3] [ 67%] ERROR tests/integration/test_plugins.py::TestPlugin::test_execution_hooks[chromium] 
_________ ERROR at setup of TestPlugin.test_execution_hooks[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_execution_hooks[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 67%] ERROR tests/integration/test_plugins.py::TestPlugin::test_execution_hooks[chromium] 
________ ERROR at teardown of TestPlugin.test_execution_hooks[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5a7f50>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5a7f50>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPlugin' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_plugins.py::TestPlugin::test_fetch_plugin_no_file_extension[chromium] 
[gw3] [ 68%] ERROR tests/integration/test_plugins.py::TestPlugin::test_fetch_plugin_no_file_extension[chromium] 
__ ERROR at setup of TestPlugin.test_fetch_plugin_no_file_extension[chromium] __
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_fetch_plugin_no_file_extension[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 68%] ERROR tests/integration/test_plugins.py::TestPlugin::test_fetch_plugin_no_file_extension[chromium] 
_ ERROR at teardown of TestPlugin.test_fetch_plugin_no_file_extension[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5bb1d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5bb1d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPlugin' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_02_display.py::TestOutput::test_simple_display[chromium] 
[gw3] [ 68%] ERROR tests/integration/test_02_display.py::TestOutput::test_simple_display[chromium] 
__________ ERROR at setup of TestOutput.test_simple_display[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_simple_display[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 68%] ERROR tests/integration/test_02_display.py::TestOutput::test_simple_display[chromium] 
________ ERROR at teardown of TestOutput.test_simple_display[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7fb36c5515d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_02_display.TestOutput object at 0x7fb36c5515d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutput' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin_non_existent[chromium] 
[gw3] [ 69%] ERROR tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin_non_existent[chromium] 
___ ERROR at setup of TestPlugin.test_fetch_js_plugin_non_existent[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_fetch_js_plugin_non_existent[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 69%] ERROR tests/integration/test_plugins.py::TestPlugin::test_fetch_js_plugin_non_existent[chromium] 
_ ERROR at teardown of TestPlugin.test_fetch_js_plugin_non_existent[chromium] __
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5bb6d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5bb6d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPlugin' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_config.py::TestConfig::test_multiple_py_config[chromium] 
[gw3] [ 69%] ERROR tests/integration/test_py_config.py::TestConfig::test_multiple_py_config[chromium] 
________ ERROR at setup of TestConfig.test_multiple_py_config[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_multiple_py_config[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 69%] ERROR tests/integration/test_py_config.py::TestConfig::test_multiple_py_config[chromium] 
______ ERROR at teardown of TestConfig.test_multiple_py_config[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_config.TestConfig object at 0x7fb367f09ad0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_config.TestConfig object at 0x7fb367f09ad0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestConfig' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_bokeh[chromium] 
[gw3] [ 70%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_bokeh[chromium] 
_____________ ERROR at setup of TestExamples.test_bokeh[chromium] ______________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_bokeh[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 70%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_bokeh[chromium] 
____________ ERROR at teardown of TestExamples.test_bokeh[chromium] ____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3aa3d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3aa3d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_folium[chromium] 
[gw3] [ 70%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_folium[chromium] 
_____________ ERROR at setup of TestExamples.test_folium[chromium] _____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_folium[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 70%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_folium[chromium] 
___________ ERROR at teardown of TestExamples.test_folium[chromium] ____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c397690>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c397690>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_02_display.py::TestOutput::test_image_display[chromium] 
[gw3] [ 71%] ERROR tests/integration/test_02_display.py::TestOutput::test_image_display[chromium] 
__________ ERROR at setup of TestOutput.test_image_display[chromium] ___________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_image_display[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 71%] ERROR tests/integration/test_02_display.py::TestOutput::test_image_display[chromium] 
_________ ERROR at teardown of TestOutput.test_image_display[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7fb36c572090>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_02_display.TestOutput object at 0x7fb36c572090>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutput' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_03_element.py::TestElement::test_element_remove_multiple_classes[chromium] 
[gw3] [ 71%] ERROR tests/integration/test_03_element.py::TestElement::test_element_remove_multiple_classes[chromium] 
_ ERROR at setup of TestElement.test_element_remove_multiple_classes[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_element_remove_multiple_classes[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 71%] ERROR tests/integration/test_03_element.py::TestElement::test_element_remove_multiple_classes[chromium] 
_ ERROR at teardown of TestElement.test_element_remove_multiple_classes[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_03_element.TestElement object at 0x7fb36c58e310>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_03_element.TestElement object at 0x7fb36c58e310>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestElement' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_display_async[chromium] 
[gw3] [ 72%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_display_async[chromium] 
____ ERROR at setup of TestPyRepl.test_repl_output_display_async[chromium] _____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_repl_output_display_async[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 72%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_display_async[chromium] 
___ ERROR at teardown of TestPyRepl.test_repl_output_display_async[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f38d90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f38d90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyRepl' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_config.py::TestConfig::test_paths_that_do_not_exist[chromium] 
[gw3] [ 72%] ERROR tests/integration/test_py_config.py::TestConfig::test_paths_that_do_not_exist[chromium] 
_____ ERROR at setup of TestConfig.test_paths_that_do_not_exist[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_paths_that_do_not_exist[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 72%] ERROR tests/integration/test_py_config.py::TestConfig::test_paths_that_do_not_exist[chromium] 
____ ERROR at teardown of TestConfig.test_paths_that_do_not_exist[chromium] ____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_config.TestConfig object at 0x7fb367f0bc90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_config.TestConfig object at 0x7fb367f0bc90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestConfig' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_00_support.py::TestSupport::test_console[chromium] 
[gw3] [ 73%] ERROR tests/integration/test_00_support.py::TestSupport::test_console[chromium] 
_____________ ERROR at setup of TestSupport.test_console[chromium] _____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_console[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 73%] ERROR tests/integration/test_00_support.py::TestSupport::test_console[chromium] 
___________ ERROR at teardown of TestSupport.test_console[chromium] ____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_00_support.TestSupport object at 0x7fb36e880d90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_00_support.TestSupport object at 0x7fb36e880d90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSupport' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_terminal.py::TestPyTerminal::test_config_false[chromium] 
[gw3] [ 73%] ERROR tests/integration/test_py_terminal.py::TestPyTerminal::test_config_false[chromium] 
_________ ERROR at setup of TestPyTerminal.test_config_false[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_config_false[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 73%] ERROR tests/integration/test_py_terminal.py::TestPyTerminal::test_config_false[chromium] 
_______ ERROR at teardown of TestPyTerminal.test_config_false[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_terminal.TestPyTerminal object at 0x7fb367f503d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_terminal.TestPyTerminal object at 0x7fb367f503d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyTerminal' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_01_basic.py::TestBasic::test_no_python_wheel[chromium] 
[gw3] [ 74%] ERROR tests/integration/test_01_basic.py::TestBasic::test_no_python_wheel[chromium] 
__________ ERROR at setup of TestBasic.test_no_python_wheel[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_no_python_wheel[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 74%] ERROR tests/integration/test_01_basic.py::TestBasic::test_no_python_wheel[chromium] 
________ ERROR at teardown of TestBasic.test_no_python_wheel[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ef990>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36e8ef990>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_03_element.py::TestElement::test_element_select[chromium] 
[gw3] [ 74%] ERROR tests/integration/test_03_element.py::TestElement::test_element_select[chromium] 
_________ ERROR at setup of TestElement.test_element_select[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_element_select[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 74%] ERROR tests/integration/test_03_element.py::TestElement::test_element_select[chromium] 
________ ERROR at teardown of TestElement.test_element_select[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_03_element.TestElement object at 0x7fb36c57fd10>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_03_element.TestElement object at 0x7fb36c57fd10>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestElement' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_repl.py::TestPyRepl::test_execute_on_shift_enter[chromium] 
[gw3] [ 75%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_execute_on_shift_enter[chromium] 
______ ERROR at setup of TestPyRepl.test_execute_on_shift_enter[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_execute_on_shift_enter[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 75%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_execute_on_shift_enter[chromium] 
____ ERROR at teardown of TestPyRepl.test_execute_on_shift_enter[chromium] _____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f1f390>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f1f390>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyRepl' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_01_basic.py::TestBasic::test_deprecated_globals[chromium] 
[gw3] [ 75%] ERROR tests/integration/test_01_basic.py::TestBasic::test_deprecated_globals[chromium] 
________ ERROR at setup of TestBasic.test_deprecated_globals[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_deprecated_globals[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 75%] ERROR tests/integration/test_01_basic.py::TestBasic::test_deprecated_globals[chromium] 
_______ ERROR at teardown of TestBasic.test_deprecated_globals[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36eac4490>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36eac4490>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_00_support.py::TestSupport::test_check_js_errors_multiple[chromium] 
[gw3] [ 76%] ERROR tests/integration/test_00_support.py::TestSupport::test_check_js_errors_multiple[chromium] 
____ ERROR at setup of TestSupport.test_check_js_errors_multiple[chromium] _____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_check_js_errors_multiple[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 76%] ERROR tests/integration/test_00_support.py::TestSupport::test_check_js_errors_multiple[chromium] 
___ ERROR at teardown of TestSupport.test_check_js_errors_multiple[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_00_support.TestSupport object at 0x7fb36e882450>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_00_support.TestSupport object at 0x7fb36e882450>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSupport' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_stderr[chromium] 
[gw3] [ 76%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_stderr[chromium] 
________ ERROR at setup of TestPyRepl.test_repl_output_stderr[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_repl_output_stderr[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 76%] ERROR tests/integration/test_py_repl.py::TestPyRepl::test_repl_output_stderr[chromium] 
______ ERROR at teardown of TestPyRepl.test_repl_output_stderr[chromium] _______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f3af90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_repl.TestPyRepl object at 0x7fb367f3af90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPyRepl' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_antigravity[chromium] 
[gw3] [ 77%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_antigravity[chromium] 
__________ ERROR at setup of TestExamples.test_antigravity[chromium] ___________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_antigravity[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 77%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_antigravity[chromium] 
_________ ERROR at teardown of TestExamples.test_antigravity[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3a9a50>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3a9a50>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_01_basic.py::TestBasic::test_python_version[chromium] 
[gw3] [ 78%] ERROR tests/integration/test_01_basic.py::TestBasic::test_python_version[chromium] 
__________ ERROR at setup of TestBasic.test_python_version[chromium] ___________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_python_version[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 78%] ERROR tests/integration/test_01_basic.py::TestBasic::test_python_version[chromium] 
_________ ERROR at teardown of TestBasic.test_python_version[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_01_basic.TestBasic object at 0x7fb36eac61d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_01_basic.TestBasic object at 0x7fb36eac61d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestBasic' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_d3[chromium] 
[gw3] [ 78%] SKIPPED tests/integration/test_zz_examples.py::TestExamples::test_d3[chromium] 
tests/integration/test_plugins.py::TestPlugin::test_pyscript_exec_hooks[chromium] 
[gw3] [ 79%] ERROR tests/integration/test_plugins.py::TestPlugin::test_pyscript_exec_hooks[chromium] 
_______ ERROR at setup of TestPlugin.test_pyscript_exec_hooks[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_pyscript_exec_hooks[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 79%] ERROR tests/integration/test_plugins.py::TestPlugin::test_pyscript_exec_hooks[chromium] 
______ ERROR at teardown of TestPlugin.test_pyscript_exec_hooks[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5b8810>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5b8810>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPlugin' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_matplotlib[chromium] 
[gw3] [ 79%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_matplotlib[chromium] 
___________ ERROR at setup of TestExamples.test_matplotlib[chromium] ___________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_matplotlib[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 79%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_matplotlib[chromium] 
_________ ERROR at teardown of TestExamples.test_matplotlib[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3954d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3954d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_todo[chromium] 
[gw3] [ 80%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_todo[chromium] 
______________ ERROR at setup of TestExamples.test_todo[chromium] ______________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_todo[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 80%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_todo[chromium] 
____________ ERROR at teardown of TestExamples.test_todo[chromium] _____________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c37cc50>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c37cc50>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_plugins.py::TestPlugin::test_fetch_python_plugin[chromium] 
[gw3] [ 80%] ERROR tests/integration/test_plugins.py::TestPlugin::test_fetch_python_plugin[chromium] 
_______ ERROR at setup of TestPlugin.test_fetch_python_plugin[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_fetch_python_plugin[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 80%] ERROR tests/integration/test_plugins.py::TestPlugin::test_fetch_python_plugin[chromium] 
______ ERROR at teardown of TestPlugin.test_fetch_python_plugin[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5ba1d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_plugins.TestPlugin object at 0x7fb36c5ba1d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestPlugin' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected[chromium] 
[gw3] [ 81%] ERROR tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected[chromium] 
____ ERROR at setup of TestSupport.test_check_js_errors_expected[chromium] _____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_check_js_errors_expected[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 81%] ERROR tests/integration/test_00_support.py::TestSupport::test_check_js_errors_expected[chromium] 
___ ERROR at teardown of TestSupport.test_check_js_errors_expected[chromium] ___
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_00_support.TestSupport object at 0x7fb36e881a50>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_00_support.TestSupport object at 0x7fb36e881a50>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSupport' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_disabled_option[chromium] 
[gw3] [ 81%] ERROR tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_disabled_option[chromium] 
_ ERROR at setup of TestSplashscreen.test_splashscreen_disabled_option[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_splashscreen_disabled_option[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 81%] ERROR tests/integration/test_splashscreen.py::TestSplashscreen::test_splashscreen_disabled_option[chromium] 
_ ERROR at teardown of TestSplashscreen.test_splashscreen_disabled_option[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_splashscreen.TestSplashscreen object at 0x7fb367f52f90>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_splashscreen.TestSplashscreen object at 0x7fb367f52f90>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSplashscreen' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_linebreaks[chromium] 
[gw3] [ 82%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_linebreaks[chromium] 
_ ERROR at setup of TestOutputHandling.test_targeted_stdio_linebreaks[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_targeted_stdio_linebreaks[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 82%] ERROR tests/integration/test_stdio_handling.py::TestOutputHandling::test_targeted_stdio_linebreaks[chromium] 
_ ERROR at teardown of TestOutputHandling.test_targeted_stdio_linebreaks[chromium] _
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f5ce50>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_stdio_handling.TestOutputHandling object at 0x7fb367f5ce50>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutputHandling' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_02_display.py::TestOutput::test_target_attribute[chromium] 
[gw3] [ 82%] ERROR tests/integration/test_02_display.py::TestOutput::test_target_attribute[chromium] 
_________ ERROR at setup of TestOutput.test_target_attribute[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_target_attribute[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 82%] ERROR tests/integration/test_02_display.py::TestOutput::test_target_attribute[chromium] 
_______ ERROR at teardown of TestOutput.test_target_attribute[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_02_display.TestOutput object at 0x7fb36c552790>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_02_display.TestOutput object at 0x7fb36c552790>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestOutput' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_03_element.py::TestElement::test_element_clone_with_id[chromium] 
[gw3] [ 83%] ERROR tests/integration/test_03_element.py::TestElement::test_element_clone_with_id[chromium] 
______ ERROR at setup of TestElement.test_element_clone_with_id[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_element_clone_with_id[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 83%] ERROR tests/integration/test_03_element.py::TestElement::test_element_clone_with_id[chromium] 
____ ERROR at teardown of TestElement.test_element_clone_with_id[chromium] _____
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_03_element.TestElement object at 0x7fb36c58c990>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_03_element.TestElement object at 0x7fb36c58c990>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestElement' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_00_support.py::TestSupport::test_iter_locator[chromium] 
[gw3] [ 83%] ERROR tests/integration/test_00_support.py::TestSupport::test_iter_locator[chromium] 
__________ ERROR at setup of TestSupport.test_iter_locator[chromium] ___________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_iter_locator[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 83%] ERROR tests/integration/test_00_support.py::TestSupport::test_iter_locator[chromium] 
_________ ERROR at teardown of TestSupport.test_iter_locator[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_00_support.TestSupport object at 0x7fb36e88a910>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_00_support.TestSupport object at 0x7fb36e88a910>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestSupport' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_py_config.py::TestConfig::test_invalid_toml_config[chromium] 
[gw3] [ 84%] ERROR tests/integration/test_py_config.py::TestConfig::test_invalid_toml_config[chromium] 
_______ ERROR at setup of TestConfig.test_invalid_toml_config[chromium] ________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_invalid_toml_config[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 84%] ERROR tests/integration/test_py_config.py::TestConfig::test_invalid_toml_config[chromium] 
______ ERROR at teardown of TestConfig.test_invalid_toml_config[chromium] ______
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_py_config.TestConfig object at 0x7fb367f09250>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_py_config.TestConfig object at 0x7fb367f09250>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestConfig' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_panel_kmeans[chromium] 
[gw3] [ 84%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_panel_kmeans[chromium] 
__________ ERROR at setup of TestExamples.test_panel_kmeans[chromium] __________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

browser = <Browser type=<BrowserType name=chromium executable_path=/home/jglass/.cache/ms-playwright/chromium-1055/chrome-linux/chrome> version=112.0.5615.29>
browser_context_args = {}
pytestconfig = <_pytest.config.Config object at 0x7fb36f5d7390>
request = <SubRequest 'context' for <Function test_panel_kmeans[chromium]>>

    @pytest.fixture
    def context(
        browser: Browser,
        browser_context_args: Dict,
        pytestconfig: Any,
        request: pytest.FixtureRequest,
    ) -> Generator[BrowserContext, None, None]:
        pages: List[Page] = []
>       context = browser.new_context(**browser_context_args)

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/sync_api/_generated.py:13989: in new_context
    self._sync(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_browser.py:126: in new_context
    channel = await self._channel.send("newContext", params)
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:61: in send
    return await self._connection.wrap_api_call(
/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:461: in wrap_api_call
    return await cb()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright._impl._connection.Channel object at 0x7fb36eae39d0>
method = 'newContext', params = {}, return_as_dict = False

    async def inner_send(
        self, method: str, params: Optional[Dict], return_as_dict: bool
    ) -> Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        if self._connection._error:
            error = self._connection._error
            self._connection._error = None
            raise error
        done, _ = await asyncio.wait(
            {
                self._connection._transport.on_error_future,
                callback.future,
            },
            return_when=asyncio.FIRST_COMPLETED,
        )
        if not callback.future.done():
            callback.future.cancel()
>       result = next(iter(done)).result()
E       playwright._impl._api_types.Error: Target page, context or browser has been closed

/home/jglass/Documents/pyscript/pyscriptjs/env/lib/python3.11/site-packages/playwright/_impl/_connection.py:96: Error
[gw3] [ 84%] ERROR tests/integration/test_zz_examples.py::TestExamples::test_panel_kmeans[chromium] 
________ ERROR at teardown of TestExamples.test_panel_kmeans[chromium] _________
[gw3] linux -- Python 3.11.0 /home/jglass/Documents/pyscript/pyscriptjs/env/bin/python

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3956d0>

    def teardown_method(self):
        # we call check_js_errors on teardown: this means that if there are still
        # non-cleared errors, the test will fail. If you expect errors in your
        # page and they should not cause the test to fail, you should call
        # self.check_js_errors() in the test itself.
>       self.check_js_errors()

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <integration.test_zz_examples.TestExamples object at 0x7fb35c3956d0>
expected_messages = []

    def check_js_errors(self, *expected_messages):
        """
        Check whether JS errors were reported.
    
        expected_messages is a list of strings of errors that you expect they
        were raised in the page.  They are checked using a simple 'in' check,
        equivalent to this:
            if expected_message in actual_error_message:
                ...
    
        If an error was expected but not found, it raises
        DidNotRaiseJsError().
    
        If there are MORE errors other than the expected ones, it raises JsErrors.
    
        Upon return, all the errors are cleared, so a subsequent call to
        check_js_errors will not raise, unless NEW JS errors have been reported
        in the meantime.
        """
        expected_messages = list(expected_messages)
>       js_errors = self._js_errors[:]
E       AttributeError: 'TestExamples' object has no attribute '_js_errors'

/home/jglass/Documents/pyscript/pyscriptjs/tests/integration/support.py:177: AttributeError

tests/integration/test_zz_examples.py::TestExamples::test_webgl_raycaster_index[chromium] 